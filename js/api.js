// API INTEGRATION FUNCTIONS
// =============================================================================

// Track provider connection status for settings UI
const providerStatuses = {
  METALS_DEV: "disconnected",
  METALS_API: "disconnected",
  METAL_PRICE_API: "disconnected",
  CUSTOM: "disconnected",
};

const renderApiStatusSummary = () => {
  const container = document.getElementById("apiStatusSummary");
  if (!container) return;
  const html = Object.keys(API_PROVIDERS)
    .map((prov) => {
      const status = providerStatuses[prov] || "disconnected";
      const name = API_PROVIDERS[prov].name;
      const statusText =
        status === "connected"
          ? "Connected"
          : status === "error"
            ? "Error"
            : "Disconnected";
      return `<span class="status-item ${status}">${name}: ${statusText}</span>`;
    })
    .join("");
  container.innerHTML = html;
};

// API history table state
let apiHistoryEntries = [];
let apiHistoryPage = 1;
const API_HISTORY_PAGE_SIZE = 10;
let apiHistorySortColumn = "";
let apiHistorySortAsc = true;
let apiHistoryFilterText = "";

/**
 * Loads API configuration from localStorage
 * @returns {Object|null} API configuration or null if not set
 */
const loadApiConfig = () => {
  try {
    const stored = localStorage.getItem(API_KEY_STORAGE_KEY);
    if (stored) {
      const config = JSON.parse(stored);
      if (config.keys) {
        Object.keys(config.keys).forEach((p) => {
          if (config.keys[p]) {
            config.keys[p] = atob(config.keys[p]);
          }
        });
      } else if (config.apiKey && config.provider) {
        // Legacy format migration
        config.keys = { [config.provider]: atob(config.apiKey) };
      }
      const usage = config.usage || {};
      const metals = config.metals || {};
      const currentMonth = currentMonthKey();
      const savedMonth = config.usageMonth;
      Object.keys(API_PROVIDERS).forEach((p) => {
        if (!usage[p]) usage[p] = { quota: DEFAULT_API_QUOTA, used: 0 };
        if (!metals[p])
          metals[p] = {
            silver: true,
            gold: true,
            platinum: true,
            palladium: true,
          };
        else {
          ["silver", "gold", "platinum", "palladium"].forEach((m) => {
            if (typeof metals[p][m] === "undefined") metals[p][m] = true;
          });
        }
      });
      let needsSave = false;
      if (savedMonth !== currentMonth) {
        Object.keys(usage).forEach((p) => (usage[p].used = 0));
        needsSave = true;
      }
      const result = {
        provider: config.provider || "",
        keys: config.keys || {},
        cacheHours:
          typeof config.cacheHours === "number" ? config.cacheHours : 24,
        customConfig: config.customConfig || {
          baseUrl: "",
          endpoint: "",
          format: "symbol",
        },
        metals,
        usage,
        usageMonth: currentMonth,
      };
      if (needsSave) {
        saveApiConfig(result);
      }
      return result;
    }
  } catch (error) {
    console.error("Error loading API config:", error);
  }
  const usage = {};
  const metals = {};
  Object.keys(API_PROVIDERS).forEach((p) => {
    usage[p] = { quota: DEFAULT_API_QUOTA, used: 0 };
    metals[p] = { silver: true, gold: true, platinum: true, palladium: true };
  });
  return {
    provider: "",
    keys: {},
    cacheHours: 24,
    customConfig: { baseUrl: "", endpoint: "", format: "symbol" },
    metals,
    usage,
    usageMonth: currentMonthKey(),
  };
};

/**
 * Saves API configuration to localStorage
 * @param {Object} config - API configuration object
 */
const saveApiConfig = (config) => {
  try {
    const configToSave = {
      provider: config.provider || "",
      keys: {},
      cacheHours:
        typeof config.cacheHours === "number" ? config.cacheHours : 24,
      customConfig: config.customConfig || {
        baseUrl: "",
        endpoint: "",
        format: "symbol",
      },
      metals: config.metals || {},
      usage: config.usage || {},
      usageMonth: config.usageMonth || currentMonthKey(),
    };
    Object.keys(config.keys || {}).forEach((p) => {
      if (config.keys[p]) {
        configToSave.keys[p] = btoa(config.keys[p]);
      }
    });
    localStorage.setItem(API_KEY_STORAGE_KEY, JSON.stringify(configToSave));
    apiConfig = config;
    updateSyncButtonStates();
  } catch (error) {
    console.error("Error saving API config:", error);
  }
};

/**
 * Clears API configuration
 */
const clearApiConfig = () => {
  localStorage.removeItem(API_KEY_STORAGE_KEY);
  localStorage.removeItem(API_CACHE_KEY);
  apiConfig = {
    provider: "",
    keys: {},
    cacheHours: 24,
    customConfig: { baseUrl: "", endpoint: "", format: "symbol" },
  };
  apiCache = null;
  Object.keys(providerStatuses).forEach((p) =>
    setProviderStatus(p, "disconnected"),
  );
  updateSyncButtonStates();
};

/**
 * Clears only the API cache, keeping the configuration
 */
const clearApiCache = () => {
  localStorage.removeItem(API_CACHE_KEY);
  apiCache = null;
  clearApiHistory(true);
  alert(
    "API cache and history cleared. Next sync will pull fresh data from the API.",
  );
};

/**
 * Gets cache duration in milliseconds
 * @returns {number} Cache duration
 */
const getCacheDurationMs = () => {
  const hours = apiConfig?.cacheHours ?? 24;
  return hours * 60 * 60 * 1000;
};

/**
 * Sets connection status for a provider in the settings UI
 * @param {string} provider
 * @param {"connected"|"disconnected"|"error"} status
 */
const setProviderStatus = (provider, status) => {
  providerStatuses[provider] = status;
  renderApiStatusSummary();
  const block = document.querySelector(
    `.api-provider[data-provider="${provider}"] .provider-status`,
  );
  if (!block) return;
  block.classList.remove(
    "status-connected",
    "status-disconnected",
    "status-error",
  );
  block.classList.add(`status-${status}`);
  const text = block.querySelector(".status-text");
  if (text) {
    text.textContent =
      status === "connected"
        ? "Connected"
        : status === "error"
          ? "Error"
          : "Disconnected";
  }
};

/**
 * Updates provider history tables with latest API values
 */
const updateProviderHistoryTables = () => {
  loadSpotHistory();
  const history = spotHistory.filter((e) => e.source === "api");
  const config = loadApiConfig();
  Object.keys(API_PROVIDERS).forEach((prov) => {
    const container = document.querySelector(
      `.api-provider[data-provider="${prov}"] .provider-history`,
    );
    if (!container) return;
    const providerName = API_PROVIDERS[prov].name;
    const metals = ["Silver", "Gold", "Platinum", "Palladium"];
    const selections = config.metals?.[prov] || {};
    let table = '<table class="provider-table"><tr class="provider-price-row"><th class="provider-label">Last Price:</th>';
    let checkboxRow =
      '<tr class="provider-checkbox-row"><th class="provider-label">Enable:</th>';
    metals.forEach((metal) => {
      const entries = history.filter(
        (e) => e.provider === providerName && e.metal === metal,
      );
      const last = entries.length
        ? formatDollar(entries[entries.length - 1].spot)
        : "-";
      const key = metal.toLowerCase();
      const checked = selections[key] !== false ? "checked" : "";
      table += `<td>${last}</td>`;
      checkboxRow += `<td><label><input type="checkbox" class="provider-metal" data-provider="${prov}" data-metal="${key}" ${checked}/><span class="provider-metal-name">${metal}</span></label></td>`;
    });
    table += '</tr>';
    checkboxRow += '</tr></table>';
    const usage = config.usage?.[prov] || {
      quota: DEFAULT_API_QUOTA,
      used: 0,
    };
    const usedPercent = Math.min((usage.used / usage.quota) * 100, 100);
    const remainingPercent = 100 - usedPercent;
    const warning = usage.used / usage.quota >= 0.9;
    const usageHtml = `<div class="api-usage"><div class="usage-bar"><div class="used" style="width:${usedPercent}%"></div><div class="remaining" style="width:${remainingPercent}%"></div></div><div class="usage-text">${usage.used}/${usage.quota} calls${warning ? " üö©" : ""}</div></div>`;
    container.innerHTML = table + checkboxRow + usageHtml;
    container.querySelectorAll(".provider-metal").forEach((cb) => {
      cb.addEventListener("change", (e) => {
        const provId = e.target.dataset.provider;
        const metalKey = e.target.dataset.metal;
        const cfg = loadApiConfig();
        if (!cfg.metals[provId]) cfg.metals[provId] = {};
        cfg.metals[provId][metalKey] = e.target.checked;
        saveApiConfig(cfg);
      });
    });
  });
};

/**
 * Updates default provider button states
 */
const updateDefaultProviderButtons = () => {
  const config = loadApiConfig();
  const keys = config.keys || {};
  const active = Object.keys(API_PROVIDERS).filter((p) => keys[p]);
  if (active.length === 1) {
    config.provider = active[0];
    saveApiConfig(config);
  }
  Object.keys(API_PROVIDERS).forEach((prov) => {
    const btn = document.querySelector(
      `.provider-default-btn[data-provider="${prov}"]`,
    );
    if (!btn) return;
    btn.classList.remove("default", "backup", "inactive");
    if (config.provider === prov && keys[prov]) {
      btn.textContent = "Default";
      btn.classList.add("default");
    } else if (keys[prov]) {
      btn.textContent = "Backup";
      btn.classList.add("backup");
    } else {
      btn.textContent = "Not in use";
      btn.classList.add("inactive");
    }
  });
};

/**
 * Renders API history table with filtering, sorting and pagination
 */
const renderApiHistoryTable = () => {
  const table = document.getElementById("apiHistoryTable");
  if (!table) return;
  let data = [...apiHistoryEntries];
  if (apiHistoryFilterText) {
    const f = apiHistoryFilterText.toLowerCase();
    data = data.filter((e) =>
      Object.values(e).some((v) => String(v).toLowerCase().includes(f)),
    );
  }
  if (apiHistorySortColumn) {
    data.sort((a, b) => {
      const valA = a[apiHistorySortColumn];
      const valB = b[apiHistorySortColumn];
      if (valA < valB) return apiHistorySortAsc ? -1 : 1;
      if (valA > valB) return apiHistorySortAsc ? 1 : -1;
      return 0;
    });
  }
  const totalPages = Math.max(
    1,
    Math.ceil(data.length / API_HISTORY_PAGE_SIZE),
  );
  apiHistoryPage = Math.min(apiHistoryPage, totalPages);
  const start = (apiHistoryPage - 1) * API_HISTORY_PAGE_SIZE;
  const pageData = data.slice(start, start + API_HISTORY_PAGE_SIZE);

  let html =
    "<tr><th data-column=\"timestamp\">Time</th><th data-column=\"metal\">Metal</th><th data-column=\"spot\">Price</th><th data-column=\"provider\">API</th></tr>";
  pageData.forEach((e) => {
    html += `<tr><td>${e.timestamp}</td><td>${e.metal}</td><td>${formatDollar(
      e.spot,
    )}</td><td>${e.provider || ""}</td></tr>`;
  });
  table.innerHTML = html;

  table.querySelectorAll("th").forEach((th) => {
    th.addEventListener("click", () => {
      const col = th.dataset.column;
      if (apiHistorySortColumn === col) {
        apiHistorySortAsc = !apiHistorySortAsc;
      } else {
        apiHistorySortColumn = col;
        apiHistorySortAsc = true;
      }
      renderApiHistoryTable();
    });
  });

  const pag = document.getElementById("apiHistoryPagination");
  if (pag) {
    pag.innerHTML = "";
    const prev = document.createElement("button");
    prev.textContent = "Prev";
    prev.disabled = apiHistoryPage === 1;
    prev.onclick = () => {
      apiHistoryPage--;
      renderApiHistoryTable();
    };
    pag.appendChild(prev);

    const info = document.createElement("span");
    info.textContent = `${apiHistoryPage} / ${totalPages}`;
    pag.appendChild(info);

    const next = document.createElement("button");
    next.textContent = "Next";
    next.disabled = apiHistoryPage === totalPages;
    next.onclick = () => {
      apiHistoryPage++;
      renderApiHistoryTable();
    };
    pag.appendChild(next);
  }
};

/**
 * Renders API history chart
 */
const renderApiHistoryChart = () => {
  const ctx = document.getElementById("apiHistoryChart");
  if (ctx) {
    const metals = ["Silver", "Gold", "Platinum", "Palladium"];
    const datasets = [];
    let maxLen = 0;
    metals.forEach((metal) => {
      const data = apiHistoryEntries
        .filter((e) => e.metal === metal)
        .slice(-30)
        .map((e) => e.spot);
      if (data.length > maxLen) maxLen = data.length;
      const color = getComputedStyle(document.documentElement).getPropertyValue(
        `--${metal.toLowerCase()}`,
      );
      datasets.push({
        label: metal,
        data,
        borderColor: color,
        tension: 0.2,
      });
    });
    const labels = Array.from({ length: maxLen }, (_, i) => i + 1);
    if (chartInstances.apiHistoryChart) {
      chartInstances.apiHistoryChart.destroy();
    }
    chartInstances.apiHistoryChart = new Chart(ctx, {
      type: "line",
      data: { labels, datasets },
      options: { responsive: true, maintainAspectRatio: false },
    });
  }
};

/**
 * Shows API history modal with table and chart
 */
const showApiHistoryModal = () => {
  const modal = document.getElementById("apiHistoryModal");
  if (!modal) return;
  loadSpotHistory();
  apiHistoryEntries = spotHistory.filter((e) => e.source === "api");
  apiHistoryPage = 1;
  apiHistorySortColumn = "";
  apiHistorySortAsc = true;
  apiHistoryFilterText = "";
  const filterInput = document.getElementById("apiHistoryFilter");
  const clearFilterBtn = document.getElementById("apiHistoryClearFilterBtn");
  if (filterInput) {
    filterInput.value = "";
    filterInput.oninput = (e) => {
      apiHistoryFilterText = e.target.value;
      apiHistoryPage = 1;
      renderApiHistoryTable();
    };
  }
  if (clearFilterBtn) {
    clearFilterBtn.onclick = () => {
      apiHistoryFilterText = "";
      if (filterInput) filterInput.value = "";
      apiHistoryPage = 1;
      renderApiHistoryTable();
    };
  }
  renderApiHistoryTable();
  renderApiHistoryChart();
  modal.style.display = "flex";
};

/**
 * Hides API history modal
 */
const hideApiHistoryModal = () => {
  const modal = document.getElementById("apiHistoryModal");
  if (modal) modal.style.display = "none";
};

/**
 * Shows API providers modal
 */
const showApiProvidersModal = () => {
  const modal = document.getElementById("apiProvidersModal");
  if (modal) {
    updateProviderHistoryTables();
    modal.style.display = "flex";
  }
};

/**
 * Hides API providers modal
 */
const hideApiProvidersModal = () => {
  const modal = document.getElementById("apiProvidersModal");
  if (modal) modal.style.display = "none";
};

/**
 * Clears stored API price history
 * @param {boolean} [silent=false] - When true, does not reopen the history modal
 */
const clearApiHistory = (silent = false) => {
  spotHistory = [];
  saveSpotHistory();
  updateProviderHistoryTables();
  if (!silent) {
    showApiHistoryModal();
  }
};

/**
 * Updates default provider selection in config
 * @param {string} provider
 */
const setDefaultProvider = (provider) => {
  const config = loadApiConfig();
  if (!config.keys[provider]) {
    alert("Please enter your API key first");
    return;
  }
  config.provider = provider;
  saveApiConfig(config);
  updateDefaultProviderButtons();
  updateSyncButtonStates();
};

/**
 * Clears stored API key for a provider
 * @param {string} provider
 */
const clearApiKey = (provider) => {
  const config = loadApiConfig();
  delete config.keys[provider];
  if (config.provider === provider) {
    config.provider = "";
  }
  const active = Object.keys(API_PROVIDERS).filter((p) => config.keys[p]);
  if (active.length === 1) {
    config.provider = active[0];
  }
  saveApiConfig(config);
  const input = document.getElementById(`apiKey_${provider}`);
  if (input) input.value = "";
  if (provider === "CUSTOM") {
    config.customConfig = { baseUrl: "", endpoint: "", format: "symbol" };
    const base = document.getElementById("apiBase_CUSTOM");
    const endpoint = document.getElementById("apiEndpoint_CUSTOM");
    const format = document.getElementById("apiFormat_CUSTOM");
    if (base) base.value = "";
    if (endpoint) endpoint.value = "";
    if (format) format.value = "symbol";
    saveApiConfig(config);
  }
  setProviderStatus(provider, "disconnected");
  updateDefaultProviderButtons();
  updateProviderHistoryTables();
};

/**
 * Updates cache duration setting
 * @param {number} hours
 */
const setCacheDuration = (hours) => {
  const config = loadApiConfig();
  config.cacheHours = hours;
  saveApiConfig(config);
  if (hours === 0) {
    clearApiCache();
  }
};

/**
 * Refreshes display using cached data without making API calls
 * @returns {boolean} Success status
 */
const refreshFromCache = () => {
  const cache = loadApiCache();
  if (!cache || !cache.data) {
    return false;
  }

  let updatedCount = 0;
  Object.entries(cache.data).forEach(([metal, price]) => {
    const metalConfig = Object.values(METALS).find((m) => m.key === metal);
    if (metalConfig && price > 0) {
      // Save to localStorage
      localStorage.setItem(metalConfig.spotKey, price.toString());
      spotPrices[metal] = price;

      // Update display
      elements.spotPriceDisplay[metal].textContent = formatDollar(price);

      // Record in history as 'cached' to distinguish from fresh API calls
      recordSpot(
        price,
        "cached",
        metalConfig.name,
        API_PROVIDERS[cache.provider]?.name,
      );

      const ts = document.getElementById(`spotTimestamp${metalConfig.name}`);
      if (ts) {
        ts.textContent = getLastUpdateTime(metalConfig.name) || "No data";
      }

      updatedCount++;
    }
  });

  if (updatedCount > 0) {
    // Update summary calculations
    updateSummary();
    return true;
  }

  return false;
};

/**
 * Loads cached API data from localStorage
 * @returns {Object|null} Cached data or null if expired/not found
 */
const loadApiCache = () => {
  try {
    const stored = localStorage.getItem(API_CACHE_KEY);
    if (stored) {
      const cache = JSON.parse(stored);
      const now = new Date().getTime();

      const duration = getCacheDurationMs();
      if (cache.timestamp && now - cache.timestamp < duration) {
        return cache;
      } else {
        // Cache expired, remove it
        localStorage.removeItem(API_CACHE_KEY);
      }
    }
  } catch (error) {
    console.error("Error loading API cache:", error);
  }
  return null;
};

/**
 * Saves API data to cache
 * @param {Object} data - Data to cache
 */
const saveApiCache = (data, provider) => {
  try {
    const duration = getCacheDurationMs();
    if (duration === 0) {
      localStorage.removeItem(API_CACHE_KEY);
      apiCache = null;
      return;
    }
    const cacheObject = {
      timestamp: new Date().getTime(),
      data: data,
      provider,
    };
    localStorage.setItem(API_CACHE_KEY, JSON.stringify(cacheObject));
    apiCache = cacheObject;
  } catch (error) {
    console.error("Error saving API cache:", error);
  }
};

/**
 * Makes API request for spot prices
 * @param {string} provider - Provider key from API_PROVIDERS
 * @param {string} apiKey - API key
 * @returns {Promise<Object>} Promise resolving to spot prices data
 */
const fetchSpotPricesFromApi = async (provider, apiKey) => {
  const providerConfig = API_PROVIDERS[provider];
  if (!providerConfig) {
    throw new Error("Invalid API provider");
  }

  const config = loadApiConfig();
  const selected = config.metals?.[provider] || {};
  const usage = config.usage?.[provider] || {
    quota: DEFAULT_API_QUOTA,
    used: 0,
  };

  const results = {};
  const errors = [];

  if (provider === "CUSTOM") {
    const config = loadApiConfig();
    const custom = config.customConfig || {};
    const base = custom.baseUrl || "";
    const pattern = custom.endpoint || "";
    const format = custom.format || "symbol";
    const metalCodes = {
      silver: format === "symbol" ? "XAG" : "silver",
      gold: format === "symbol" ? "XAU" : "gold",
      platinum: format === "symbol" ? "XPT" : "platinum",
      palladium: format === "symbol" ? "XPD" : "palladium",
    };
    for (const metal of Object.keys(metalCodes)) {
      if (selected[metal] === false) continue;
      try {
        const endpoint = pattern
          .replace("{API_KEY}", apiKey)
          .replace("{METAL}", metalCodes[metal]);
        const url = `${base}${endpoint}`;
        const response = await fetch(url, {
          method: "GET",
          headers: { "Content-Type": "application/json" },
          mode: "cors",
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        usage.used++;
        const price = providerConfig.parseResponse(data, metal);
        if (price && price > 0) {
          results[metal] = price;
        } else {
          errors.push(`${metal}: Invalid price data`);
        }
      } catch (error) {
        errors.push(`${metal}: ${error.message}`);
      }
    }
  } else {
    // Fetch prices for each metal using predefined endpoints
    for (const [metal, endpoint] of Object.entries(providerConfig.endpoints)) {
      if (selected[metal] === false) continue;
      try {
        const url = `${providerConfig.baseUrl}${endpoint.replace("{API_KEY}", apiKey)}`;

        const headers = {
          "Content-Type": "application/json",
        };

        if (provider === "METALS_DEV" && apiKey) {
          headers["Authorization"] = `Bearer ${apiKey}`;
        }

        const response = await fetch(url, {
          method: "GET",
          headers: headers,
          mode: "cors",
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        usage.used++;
        const price = providerConfig.parseResponse(data, metal);

        if (price && price > 0) {
          results[metal] = price;
        } else {
          errors.push(`${metal}: Invalid price data`);
        }
      } catch (error) {
        errors.push(`${metal}: ${error.message}`);
      }
    }
  }

  if (Object.keys(results).length === 0) {
    throw new Error(`No valid prices retrieved. Errors: ${errors.join(", ")}`);
  }

  // If we got some results but not all, show a warning
  if (errors.length > 0) {
    console.warn("Some metals failed to fetch:", errors);
  }

  config.usage[provider] = usage;
  saveApiConfig(config);
  return results;
};

/**
 * Syncs spot prices from API and updates the application
 * @param {boolean} showProgress - Whether to show progress indicators
 * @param {boolean} forceSync - Whether to force sync even if cache is valid
 * @returns {Promise<boolean>} Promise resolving to success status
 */
const syncSpotPricesFromApi = async (
  showProgress = true,
  forceSync = false,
) => {
  if (
    !apiConfig ||
    !apiConfig.provider ||
    !apiConfig.keys[apiConfig.provider]
  ) {
    alert(
      "No API configuration found. Please configure an API provider first.",
    );
    return false;
  }

  // Check cache age if not forcing sync
  if (!forceSync) {
    const cache = loadApiCache();
    if (cache && cache.data && cache.timestamp) {
      const now = new Date().getTime();
      const cacheAge = now - cache.timestamp;
      const duration = getCacheDurationMs();

      if (cacheAge < duration) {
        if (showProgress) {
          const hoursAgo = Math.floor(cacheAge / (1000 * 60 * 60));
          const minutesAgo = Math.floor(cacheAge / (1000 * 60));
          const timeText =
            hoursAgo > 0
              ? `${hoursAgo} hours ago`
              : `${minutesAgo} minutes ago`;

          alert(
            `Using cached prices from ${timeText}. To pull fresh data from the API, go to the API configuration and clear the cache first.`,
          );
        }

        // Use cached data to refresh display
        return refreshFromCache();
      }
    }
  }

  if (showProgress) {
    updateSyncButtonStates(true); // Show syncing state
  }

  try {
    const spotPricesData = await fetchSpotPricesFromApi(
      apiConfig.provider,
      apiConfig.keys[apiConfig.provider],
    );

    // Update spot prices in the application
    let updatedCount = 0;
    Object.entries(spotPricesData).forEach(([metal, price]) => {
      const metalConfig = Object.values(METALS).find((m) => m.key === metal);
      if (metalConfig && price > 0) {
        // Save to localStorage
        localStorage.setItem(metalConfig.spotKey, price.toString());
        spotPrices[metal] = price;

        // Update display
        elements.spotPriceDisplay[metal].textContent = formatDollar(price);

        // Record in history
        recordSpot(
          price,
          "api",
          metalConfig.name,
          API_PROVIDERS[apiConfig.provider].name,
        );

        const ts = document.getElementById(`spotTimestamp${metalConfig.name}`);
        if (ts) {
          ts.textContent = getLastUpdateTime(metalConfig.name) || "No data";
        }

        updatedCount++;
      }
    });

    if (updatedCount > 0) {
      // Save to cache
      saveApiCache(spotPricesData, apiConfig.provider);

      // Update summary calculations
      updateSummary();

      setProviderStatus(apiConfig.provider, "connected");

      if (showProgress) {
        alert(
          `Successfully synced ${updatedCount} metal prices from ${API_PROVIDERS[apiConfig.provider].name}`,
        );
      }

      return true;
    } else {
      setProviderStatus(apiConfig.provider, "error");
      throw new Error("No valid prices were retrieved from API");
    }
  } catch (error) {
    console.error("API sync error:", error);
    setProviderStatus(apiConfig.provider, "error");
    if (showProgress) {
      alert(`Failed to sync prices: ${error.message}`);
    }
    return false;
  } finally {
    if (showProgress) {
      updateSyncButtonStates(false); // Reset sync button states
    }
  }
};

/**
 * Tests API connection
 * @param {string} provider - Provider key
 * @param {string} apiKey - API key to test
 * @returns {Promise<boolean>} Promise resolving to connection test result
 */
const testApiConnection = async (provider, apiKey) => {
  try {
    // Just test one metal (silver) to verify connection
    const providerConfig = API_PROVIDERS[provider];
    if (!providerConfig) {
      throw new Error("Invalid provider");
    }

    let url = "";
    const headers = {
      "Content-Type": "application/json",
    };
    if (provider === "CUSTOM") {
      const config = loadApiConfig();
      const custom = config.customConfig || {};
      const metal = custom.format === "word" ? "silver" : "XAG";
      url = `${custom.baseUrl || ""}${(custom.endpoint || "")
        .replace("{API_KEY}", apiKey)
        .replace("{METAL}", metal)}`;
    } else {
      const endpoint = providerConfig.endpoints.silver;
      url = `${providerConfig.baseUrl}${endpoint.replace("{API_KEY}", apiKey)}`;
      if (provider === "METALS_DEV" && apiKey) {
        headers["Authorization"] = `Bearer ${apiKey}`;
      }
    }

    const response = await fetch(url, {
      method: "GET",
      headers: headers,
      mode: "cors",
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    const price = providerConfig.parseResponse(data, "silver");

    return price && price > 0;
  } catch (error) {
    console.error("API connection test failed:", error);
    return false;
  }
};

/**
 * Handles testing and syncing for a specific provider
 * @param {string} provider - Provider key
 */
const handleProviderSync = async (provider) => {
  const keyInput = document.getElementById(`apiKey_${provider}`);
  if (!keyInput) return;

  const apiKey = keyInput.value.trim();
  if (!apiKey) {
    alert("Please enter your API key");
    return;
  }

  const config = loadApiConfig();
  config.keys[provider] = apiKey;
  if (provider === "CUSTOM") {
    const base = document.getElementById("apiBase_CUSTOM")?.value.trim() || "";
    const endpoint =
      document.getElementById("apiEndpoint_CUSTOM")?.value.trim() || "";
    const format =
      document.getElementById("apiFormat_CUSTOM")?.value || "symbol";
    if (!base || !endpoint) {
      alert("Please enter base URL and endpoint");
      return;
    }
    config.customConfig = { baseUrl: base, endpoint, format };
  }
  config.timestamp = new Date().getTime();
  saveApiConfig(config);
  updateDefaultProviderButtons();
  updateSyncButtonStates();
  setProviderStatus(provider, "disconnected");

  // Test connection
  const ok = await testApiConnection(provider, apiKey);
  if (!ok) {
    alert("API connection test failed.");
    setProviderStatus(provider, "error");
    return;
  }

  try {
    const data = await fetchSpotPricesFromApi(provider, apiKey);
    let updatedCount = 0;
    Object.entries(data).forEach(([metal, price]) => {
      const metalConfig = Object.values(METALS).find((m) => m.key === metal);
      if (metalConfig && price > 0) {
        localStorage.setItem(metalConfig.spotKey, price.toString());
        spotPrices[metal] = price;
        elements.spotPriceDisplay[metal].textContent = formatDollar(price);
        recordSpot(
          price,
          "api",
          metalConfig.name,
          API_PROVIDERS[provider].name,
        );
        const ts = document.getElementById(`spotTimestamp${metalConfig.name}`);
        if (ts) {
          ts.textContent = getLastUpdateTime(metalConfig.name) || "No data";
        }
        updatedCount++;
      }
    });

    if (updatedCount > 0) {
      saveApiCache(data, provider);
      updateSummary();
      setProviderStatus(provider, "connected");
      updateProviderHistoryTables();
      alert(
        `Successfully synced ${updatedCount} metal prices from ${API_PROVIDERS[provider].name}`,
      );
    } else {
      setProviderStatus(provider, "error");
      alert("No valid prices retrieved from API");
    }
  } catch (error) {
    console.error("API sync error:", error);
    setProviderStatus(provider, "error");
    alert("Failed to sync prices: " + error.message);
  }
};

/**
 * Syncs all configured providers and records results
 */
const syncAllProviders = async () => {
  const config = loadApiConfig();
  if (!config || !config.keys) return 0;
  let updated = 0;
  for (const prov of Object.keys(API_PROVIDERS)) {
    const apiKey = config.keys[prov];
    if (!apiKey) continue;
    try {
      const data = await fetchSpotPricesFromApi(prov, apiKey);
      Object.entries(data).forEach(([metal, price]) => {
        const metalConfig = Object.values(METALS).find((m) => m.key === metal);
        if (metalConfig && price > 0) {
          recordSpot(
            price,
            "api",
            metalConfig.name,
            API_PROVIDERS[prov].name,
          );
          updated++;
        }
      });
      setProviderStatus(prov, "connected");
    } catch (err) {
      console.error(`Sync failed for ${prov}:`, err);
      setProviderStatus(prov, "error");
    }
  }
  updateProviderHistoryTables();
  return updated;
};

/**
 * Updates sync button states based on API availability
 * @param {boolean} syncing - Whether sync is in progress
 */
const updateSyncButtonStates = (syncing = false) => {
  const hasApi =
    apiConfig && apiConfig.provider && apiConfig.keys[apiConfig.provider];

  Object.values(METALS).forEach((metalConfig) => {
    const syncBtn = document.getElementById(`syncBtn${metalConfig.name}`);
    if (syncBtn) {
      syncBtn.disabled = !hasApi || syncing;
      syncBtn.textContent = syncing ? "..." : "Sync";
      syncBtn.title = hasApi
        ? syncing
          ? "Syncing..."
          : "Sync from API"
        : "Configure API first";
    }
  });
};

/**
 * Updates API status display in modal
 */
/**
 * Shows settings modal and populates API fields
 */
const showSettingsModal = () => {
  const modal = document.getElementById("settingsModal");
  if (!modal) return;
  let currentConfig = loadApiConfig() || {
    provider: "",
    keys: {},
    cacheHours: 24,
    customConfig: { baseUrl: "", endpoint: "", format: "symbol" },
  };
  if (!currentConfig.provider) {
    currentConfig.provider = Object.keys(API_PROVIDERS)[0];
    saveApiConfig(currentConfig);
  }

  const savedTheme = localStorage.getItem(THEME_KEY);
  const themeValue = savedTheme ? savedTheme : "system";
  const themeDisplay = document.getElementById("themeDisplay");
  if (themeDisplay) {
    themeDisplay.textContent =
      themeValue === "dark"
        ? "Dark Mode"
        : themeValue === "light"
          ? "Light Mode"
          : "System";
  }

  Object.keys(API_PROVIDERS).forEach((prov) => {
    const input = document.getElementById(`apiKey_${prov}`);
    if (input) input.value = currentConfig.keys?.[prov] || "";
    setProviderStatus(prov, providerStatuses[prov] || "disconnected");
  });
  renderApiStatusSummary();

  const baseInput = document.getElementById("apiBase_CUSTOM");
  if (baseInput) baseInput.value = currentConfig.customConfig?.baseUrl || "";
  const endpointInput = document.getElementById("apiEndpoint_CUSTOM");
  if (endpointInput)
    endpointInput.value = currentConfig.customConfig?.endpoint || "";
  const formatSelect = document.getElementById("apiFormat_CUSTOM");
  if (formatSelect)
    formatSelect.value = currentConfig.customConfig?.format || "symbol";

  const durationSelect = document.getElementById("apiCacheDuration");
  if (durationSelect) {
    durationSelect.value = String(currentConfig.cacheHours ?? 24);
  }
  updateDefaultProviderButtons();
  updateProviderHistoryTables();
  modal.style.display = "flex";
};

/**
 * Hides settings modal
 */
const hideSettingsModal = () => {
  const modal = document.getElementById("settingsModal");
  if (modal) {
    modal.style.display = "none";
  }
};

/**
 * Shows provider information modal
 * @param {string} providerKey
 */
const showProviderInfo = (providerKey) => {
  const modal = document.getElementById("apiInfoModal");
  if (!modal || !API_PROVIDERS[providerKey]) return;

  const provider = API_PROVIDERS[providerKey];
  const title = document.getElementById("apiInfoTitle");
  const body = document.getElementById("apiInfoBody");

  if (title) title.textContent = "Provider Information";
  if (body) {
    body.innerHTML = `
      <div class="info-provider-name">${provider.name}</div>
      <div>Base URL: ${provider.baseUrl}</div>
      <div>Metals: Silver, Gold, Platinum, Palladium</div>
      <div class="api-key-info">
        <div>üìã <strong>API Key Management:</strong></div>
        <ul>
          <li>Visit the documentation link below to manage your API key</li>
          <li>You can view usage, reset, or regenerate your key there</li>
          <li>Keep your API key secure and never share it publicly</li>
        </ul>
      </div>
      <a class="btn info-docs-btn" href="${provider.documentation}" target="_blank" rel="noopener">
        üìÑ ${provider.name} Documentation & Key Management
      </a>
    `;
  }

  modal.style.display = "flex";
};

/**
 * Hides provider information modal
 */
const hideProviderInfo = () => {
  const modal = document.getElementById("apiInfoModal");
  if (modal) {
    modal.style.display = "none";
  }
};

// Make modal controls available globally
window.showSettingsModal = showSettingsModal;
window.hideSettingsModal = hideSettingsModal;
window.showProviderInfo = showProviderInfo;
window.hideProviderInfo = hideProviderInfo;

window.handleProviderSync = handleProviderSync;
window.clearApiKey = clearApiKey;
window.clearApiCache = clearApiCache;
window.setDefaultProvider = setDefaultProvider;
window.setCacheDuration = setCacheDuration;
window.showApiHistoryModal = showApiHistoryModal;
window.hideApiHistoryModal = hideApiHistoryModal;
window.clearApiHistory = clearApiHistory;
window.syncAllProviders = syncAllProviders;

/**
 * Shows manual price input for a specific metal
 * @param {string} metal - Metal name (Silver, Gold, etc.)
 */
const showManualInput = (metal) => {
  const manualInput = document.getElementById(`manualInput${metal}`);
  if (manualInput) {
    manualInput.style.display = "block";

    // Focus the input field
    const input = document.getElementById(`userSpotPrice${metal}`);
    if (input) {
      input.focus();
    }
  }
};

/**
 * Hides manual price input for a specific metal
 * @param {string} metal - Metal name (Silver, Gold, etc.)
 */
const hideManualInput = (metal) => {
  const manualInput = document.getElementById(`manualInput${metal}`);
  if (manualInput) {
    manualInput.style.display = "none";

    // Clear the input
    const input = document.getElementById(`userSpotPrice${metal}`);
    if (input) {
      input.value = "";
    }
  }
};

/**
 * Resets spot price to default or API cached value
 * @param {string} metal - Metal name (Silver, Gold, etc.)
 */
const resetSpotPrice = (metal) => {
  const metalConfig = Object.values(METALS).find((m) => m.name === metal);
  if (!metalConfig) return;

  let resetPrice = metalConfig.defaultPrice;
  let source = "default";
  let providerName = null;

  // If we have cached API data, use that instead
  if (apiCache && apiCache.data && apiCache.data[metalConfig.key]) {
    resetPrice = apiCache.data[metalConfig.key];
    source = "api";
    providerName = API_PROVIDERS[apiCache.provider]?.name || null;
  }

  // Update price
  localStorage.setItem(metalConfig.spotKey, resetPrice.toString());
  spotPrices[metalConfig.key] = resetPrice;

  // Update display
  elements.spotPriceDisplay[metalConfig.key].textContent =
    formatDollar(resetPrice);

  // Record in history
  recordSpot(resetPrice, source, metalConfig.name, providerName);

  // Update summary
  updateSummary();

  // Hide manual input if shown
  hideManualInput(metal);
};

/**
 * Exports backup data including API configuration
 * @returns {Object} Complete backup data object
 */
const createBackupData = () => {
  const backupData = {
    version: APP_VERSION,
    timestamp: new Date().toISOString(),
    inventory: loadData(LS_KEY, []),
    spotHistory: loadData(SPOT_HISTORY_KEY, []),
    apiConfig:
      apiConfig && apiConfig.provider
        ? {
            provider: apiConfig.provider,
            providerName: API_PROVIDERS[apiConfig.provider]?.name || "Unknown",
            keyLength: apiConfig.keys[apiConfig.provider]
              ? apiConfig.keys[apiConfig.provider].length
              : 0,
            hasKey: !!apiConfig.keys[apiConfig.provider],
            timestamp: apiConfig.timestamp,
          }
        : null,
    spotPrices: { ...spotPrices },
  };

  return backupData;
};

/**
 * Downloads complete backup files including inventory and API configuration
 */
const downloadCompleteBackup = async () => {
  try {
    const timestamp = new Date()
      .toISOString()
      .slice(0, 19)
      .replace(/[T:]/g, "-");

    // 1. Create inventory CSV using existing export logic
    const inventory = loadData(LS_KEY, []);
    if (inventory.length > 0) {
      // Create CSV manually for backup instead of calling exportCsv()
      const headers = [
        "Metal",
        "Name",
        "Qty",
        "Type",
        "Weight(oz)",
        "Purchase Price",
        "Spot Price ($/oz)",
        "Premium ($/oz)",
        "Total Premium",
        "Purchase Location",
        "Storage Location",
        "Notes",
        "Date",
        "Collectable",
      ];
      const sortedInventory = [...inventory].sort(
        (a, b) => new Date(b.date) - new Date(a.date),
      );

      const rows = sortedInventory.map((item) => [
        item.metal || "Silver",
        item.name,
        item.qty,
        item.type,
        parseFloat(item.weight).toFixed(4),
        formatDollar(item.price),
        item.isCollectable ? "N/A" : formatDollar(item.spotPriceAtPurchase),
        item.isCollectable ? "N/A" : formatDollar(item.premiumPerOz),
        item.isCollectable ? "N/A" : formatDollar(item.totalPremium),
        item.purchaseLocation,
        item.storageLocation || "Unknown",
        item.notes || "",
        item.date,
        item.isCollectable ? "Yes" : "No",
      ]);

      const inventoryCsv = Papa.unparse([headers, ...rows]);
      downloadFile(
        `inventory-backup-${timestamp}.csv`,
        inventoryCsv,
        "text/csv",
      );
    }

    // 2. Create spot history CSV
    const spotHistory = loadData(SPOT_HISTORY_KEY, []);
    if (spotHistory.length > 0) {
      const historyData = [
        ["Timestamp", "Metal", "Price", "Source"],
        ...spotHistory.map((entry) => [
          entry.timestamp,
          entry.metal,
          entry.spot,
          entry.source,
        ]),
      ];

      const historyCsv = Papa.unparse(historyData);
      downloadFile(
        `spot-price-history-${timestamp}.csv`,
        historyCsv,
        "text/csv",
      );
    }

    // 3. Create complete JSON backup
    const completeBackup = {
      version: APP_VERSION,
      timestamp: new Date().toISOString(),
      data: {
        inventory: inventory,
        spotHistory: spotHistory,
        spotPrices: { ...spotPrices },
        apiConfig:
          apiConfig && apiConfig.provider
            ? {
                provider: apiConfig.provider,
                providerName:
                  API_PROVIDERS[apiConfig.provider]?.name || "Unknown",
                hasKey: !!apiConfig.keys[apiConfig.provider],
                keyLength: apiConfig.keys[apiConfig.provider]
                  ? apiConfig.keys[apiConfig.provider].length
                  : 0,
                timestamp: apiConfig.timestamp,
              }
            : null,
      },
    };

    const backupJson = JSON.stringify(completeBackup, null, 2);
    downloadFile(
      `complete-backup-${timestamp}.json`,
      backupJson,
      "application/json",
    );

    // 4. Create API documentation and restoration guide
    const backupData = createBackupData();
    const apiInfo = `# StackTrackr - Complete Backup

Generated: ${new Date().toLocaleString()}
Application Version: ${APP_VERSION}

## Backup Contents

1. **inventory-backup-${timestamp}.csv** - Complete inventory data
2. **spot-price-history-${timestamp}.csv** - Historical spot price data
3. **complete-backup-${timestamp}.json** - Full application backup
4. **backup-info-${timestamp}.md** - This documentation file

## API Configuration
${
  backupData.apiConfig
    ? `
- Provider: ${backupData.apiConfig.providerName}
- Has API Key: ${backupData.apiConfig.hasKey}
- Key Length: ${backupData.apiConfig.keyLength} characters
- Configured: ${new Date(backupData.apiConfig.timestamp).toLocaleString()}

**‚ö†Ô∏è Security Note:** API keys are not included in backups for security.
After restoring, reconfigure your API key in the API settings.

### API Key Management
${
  API_PROVIDERS[apiConfig?.provider]
    ? `
**${API_PROVIDERS[apiConfig.provider].name}**
- Documentation: ${API_PROVIDERS[apiConfig.provider].documentation}
- If you need to reset your API key, visit the documentation link above
`
    : ""
}
`
    : "No API configuration found."
}

## Current Data Summary
- Inventory Items: ${inventory.length}
- Spot Price History: ${spotHistory.length} entries
- Silver Price: ${spotPrices.silver || "Not set"}
- Gold Price: ${spotPrices.gold || "Not set"}
- Platinum Price: ${spotPrices.platinum || "Not set"}
- Palladium Price: ${spotPrices.palladium || "Not set"}

## Restoration Instructions

1. Import **inventory-backup-${timestamp}.csv** using the CSV import feature
2. Reconfigure API settings if needed (keys not backed up for security)
3. Use **complete-backup-${timestamp}.json** for full data restoration if needed

*This backup was created by StackTrackr v${APP_VERSION}*
`;

    downloadFile(`backup-info-${timestamp}.md`, apiInfo, "text/markdown");

    alert(
      `Complete backup created! Downloaded files:\n\n‚úì Inventory CSV (${inventory.length} items)\n‚úì Spot price history (${spotHistory.length} entries)\n‚úì Complete JSON backup\n‚úì Documentation & restoration guide\n\nCheck your Downloads folder.`,
    );
  } catch (error) {
    console.error("Backup error:", error);
    alert("Error creating backup: " + error.message);
  }
};

// =============================================================================
